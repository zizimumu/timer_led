#include "stm32f10x.h"
#include "delay.h"

#define SPI2CS_CLOCK  RCC_APB2Periph_GPIOB 
#define SPI2CS_PIN  GPIO_Pin_5
#define LCD_MODE_PIN GPIO_Pin_14
#define LCD_RS_PIN GPIO_Pin_6


#define SPI2CS_GPIO GPIOB

#define SPI2_CS_HIGH()  GPIO_SetBits(SPI2CS_GPIO,SPI2CS_PIN)
#define SPI2_CS_LOW() GPIO_ResetBits(SPI2CS_GPIO,SPI2CS_PIN)

#define LCD_RS_HIGH()  GPIO_SetBits(SPI2CS_GPIO,LCD_RS_PIN)
#define LCD_RS_LOW() GPIO_ResetBits(SPI2CS_GPIO,LCD_RS_PIN)


#define LCD_DO_WRITE()  GPIO_SetBits(SPI2CS_GPIO,LCD_MODE_PIN)
#define LCD_DO_CONTROL() GPIO_ResetBits(SPI2CS_GPIO,LCD_MODE_PIN)



const uint8_t  ascii_table_5x7[95][5]={
0x00,0x00,0x00,0x00,0x00,//space
0x00,0x00,0x4f,0x00,0x00,//!
0x00,0x07,0x00,0x07,0x00,//"
0x14,0x7f,0x14,0x7f,0x14,//#
0x24,0x2a,0x7f,0x2a,0x12,//$
0x23,0x13,0x08,0x64,0x62,//%
0x36,0x49,0x55,0x22,0x50,//&
0x00,0x05,0x07,0x00,0x00,//]
0x00,0x1c,0x22,0x41,0x00,//(
0x00,0x41,0x22,0x1c,0x00,//)
0x14,0x08,0x3e,0x08,0x14,//*
0x08,0x08,0x3e,0x08,0x08,//+
0x00,0x50,0x30,0x00,0x00,//,
0x08,0x08,0x08,0x08,0x08,//-
0x00,0x60,0x60,0x00,0x00,//.
0x20,0x10,0x08,0x04,0x02,///
0x3e,0x51,0x49,0x45,0x3e,//0
0x00,0x42,0x7f,0x40,0x00, // 1
0x42,0x61,0x51,0x49,0x46,// 2
0x21,0x41,0x45,0x4b,0x31,// 3
0x18,0x14,0x12,0x7f,0x10,// 4
0x27,0x45,0x45,0x45,0x39,//5
0x3c,0x4a,0x49,0x49,0x30,//6
0x01,0x71,0x09,0x05,0x03,//7
0x36,0x49,0x49,0x49,0x36,//8
0x06,0x49,0x49,0x29,0x1e,//9
0x00,0x36,0x36,0x00,0x00,//:
0x00,0x56,0x36,0x00,0x00,//;
0x08,0x14,0x22,0x41,0x00,//<
0x14,0x14,0x14,0x14,0x14,//=
0x00,0x41,0x22,0x14,0x08,//>
0x02,0x01,0x51,0x09,0x06,//?
0x32,0x49,0x79,0x41,0x3e,//@
0x7e,0x11,0x11,0x11,0x7e,//A
0x7f,0x49,0x49,0x49,0x36,//B
0x3e,0x41,0x41,0x41,0x22,//C
0x7f,0x41,0x41,0x22,0x1c,//D
0x7f,0x49,0x49,0x49,0x41,//E
0x7f,0x09,0x09,0x09,0x01,//F
0x3e,0x41,0x49,0x49,0x7a,//G
0x7f,0x08,0x08,0x08,0x7f,//H
0x00,0x41,0x7f,0x41,0x00,//I
0x20,0x40,0x41,0x3f,0x01,//J
0x7f,0x08,0x14,0x22,0x41,//K
0x7f,0x40,0x40,0x40,0x40,//L
0x7f,0x02,0x0c,0x02,0x7f,//M
0x7f,0x04,0x08,0x10,0x7f,//N
0x3e,0x41,0x41,0x41,0x3e,//O
0x7f,0x09,0x09,0x09,0x06,//P
0x3e,0x41,0x51,0x21,0x5e,//Q
0x7f,0x09,0x19,0x29,0x46,//R
0x46,0x49,0x49,0x49,0x31,//S
0x01,0x01,0x7f,0x01,0x01,//T
0x3f,0x40,0x40,0x40,0x3f,//U
0x1f,0x20,0x40,0x20,0x1f,//V
0x3f,0x40,0x38,0x40,0x3f,//W
0x63,0x14,0x08,0x14,0x63,//X
0x07,0x08,0x70,0x08,0x07,//Y
0x61,0x51,0x49,0x45,0x43,//Z
0x00,0x7f,0x41,0x41,0x00,//[
0x02,0x04,0x08,0x10,0x20,//  斜杠
0x00,0x41,0x41,0x7f,0x00,//]
0x04,0x02,0x01,0x02,0x04,//^
0x40,0x40,0x40,0x40,0x40,//_
0x01,0x02,0x04,0x00,0x00,//`
0x20,0x54,0x54,0x54,0x78,//a
0x7f,0x48,0x48,0x48,0x30,//b
0x38,0x44,0x44,0x44,0x44,//c
0x30,0x48,0x48,0x48,0x7f,//d
0x38,0x54,0x54,0x54,0x58,//e
0x00,0x08,0x7e,0x09,0x02,//f
0x48,0x54,0x54,0x54,0x3c,//g
0x7f,0x08,0x08,0x08,0x70,//h
0x00,0x00,0x7a,0x00,0x00,//i
0x20,0x40,0x40,0x3d,0x00,//j
0x7f,0x20,0x28,0x44,0x00,//k
0x00,0x41,0x7f,0x40,0x00,//l
0x7c,0x04,0x38,0x04,0x7c,//m
0x7c,0x08,0x04,0x04,0x78,//n
0x38,0x44,0x44,0x44,0x38,//o
0x7c,0x14,0x14,0x14,0x08,//p
0x08,0x14,0x14,0x14,0x7c,//q
0x7c,0x08,0x04,0x04,0x08,//r
0x48,0x54,0x54,0x54,0x24,//s
0x04,0x04,0x3f,0x44,0x24,//t
0x3c,0x40,0x40,0x40,0x3c,//u
0x1c,0x20,0x40,0x20,0x1c,//v
0x3c,0x40,0x30,0x40,0x3c,//w
0x44,0x28,0x10,0x28,0x44,//x
0x04,0x48,0x30,0x08,0x04,//y
0x44,0x64,0x54,0x4c,0x44,//z
0x08,0x36,0x41,0x41,0x00,//{
0x00,0x00,0x77,0x00,0x00,//|
0x00,0x41,0x41,0x36,0x08,//}
0x04,0x02,0x02,0x02,0x01,//~
};

void SPI2_CS_Config(void)
{
	GPIO_InitTypeDef GPIO_InitStructure;

	RCC_APB2PeriphClockCmd(SPI2CS_CLOCK, ENABLE);
	
	GPIO_InitStructure.GPIO_Pin = SPI2CS_PIN|LCD_MODE_PIN|LCD_RS_PIN;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;		
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(SPI2CS_GPIO, &GPIO_InitStructure);	
}

void LCD_WriteControl(unsigned char cmd)
{
	LCD_DO_CONTROL();
	//delay_us(10);
	SPI2_UserWriteByte(cmd);
	delay_us(10);

}
void LCD_WriteData(unsigned char data)
{
	LCD_DO_WRITE();
	//delay_us(10);
	SPI2_UserWriteByte(data);
	delay_us(10);

}


void set_ddram_line_col(unsigned char line,unsigned char col)
{

  unsigned char page,coll,coll_l,coll_h;
  page = line;
  coll = col;
  coll_h = coll>>4;
  coll_l = coll&0x0f;
  LCD_WriteControl(0xB0+page);
  delay_us(15); // 15 us
  LCD_WriteControl(0x10+coll_h);
  delay_us(15); // 15 us
  LCD_WriteControl(0x00+coll_l);
  delay_us(15); // 15 us
}
void HalLcd_HW_Clear(void)
{

  int i,j;
  for(i=0;i<8;i++){
        set_ddram_line_col(i,0);
	for(j=0;j<128;j++){
		LCD_WriteData(0x00);
	}
  }
}

void DisplayByte_5x7(unsigned char page,unsigned char column,unsigned char text)
{
	int j,k;

	if((text>=0x20)&&(text<0x7e)){/*需要显示的文字*/
		j=text-0x20;/*寻址，通过字符的ascii码找到点阵库中的改字符的位置*/
		set_ddram_line_col(page,column);
		for(k=0;k<5;k++)
		{
			LCD_WriteData(ascii_table_5x7[j][k]);/*显示5x7的ASCII字到LCD上，y为页地址，x为列地址，最后为数据*/
		}
		//第六列写入0，即清除上一次留下来的数据
		LCD_WriteData(0x00);
		column+=6;
	}else if(text==0x00){/*不需要显示，清空指定位置*/
		set_ddram_line_col(page,column);
		for(k=0;k<5;k++){
			LCD_WriteData(0x00); //清空指定的字符位置
		}
	}

}

void LCD_WriteString(char * str,unsigned char line,unsigned char column)
{
	unsigned char  i = 0;
	while(str[i] != 0){
		DisplayByte_5x7(line,column,str[i]);
		column += 7;
		i++;
	}
}

/***********************************
uint32_t sendData  : limit is 32bit
unsigned char rate : 0 -decimal  1-hex
unsigned char style: 0 - end with \r\n  1- end with ' '
429 496 729 5

**************************************/
void LCD_WriteInt(int32_t sendValue,unsigned char rate,unsigned char line,unsigned char column)
{
	unsigned char hexTmp[11];
	unsigned char decTmp[13];
	unsigned char i,value;
	uint32_t tmpValue,sendData;

	sendData = sendValue;
	if(sendValue < 0){
		DebugPrint("-");
		sendData = 0xffffffff - (uint32_t)sendValue +1;
	}
	if( 1 == rate){
		for(i=0;i<8;i++){
			value =(unsigned char)(( 0xf0000000&( sendData<<(i*4) ) )>>28 );
			if((0 <= value )&&(value <= 9))
				hexTmp[i] = value + 0x30;
			else if((10 <= value)&&(value <= 15))
				hexTmp[i] = value + 55;
		}

		hexTmp[8] = 0;

		i = 0;
		while(hexTmp[i] == '0'){
			i++;
			if(i == 8){
				LCD_WriteString((char *)&hexTmp[7],line,column);
				return ;
			}
		}
		LCD_WriteString((char *)&hexTmp[i],line,column);
	}
	else {
		tmpValue = sendData;
		for(i=0;i<10;i++){
			decTmp[9-i] = tmpValue%10 + 0x30;
			tmpValue = tmpValue/10;
		}

		decTmp[10] = 0;
		i = 0;
		while(decTmp[i] == '0'){
			i++;
			if(i == 10){
				LCD_WriteString((char *)&decTmp[9],line,column);
				return ;
			}

		}
		LCD_WriteString((char *)&decTmp[i],line,column);

	}

}

void LCD_Init(void)
{

	SPI2_UserInit();
	SPI2_CS_Config();

	LCD_RS_LOW();
	delay_us(10);
	LCD_RS_HIGH();
	
	SPI2_CS_LOW();

	LCD_WriteControl(0xe2);	//软复位
	delay_us(15); // 15 us
	LCD_WriteControl(0x2c);	//升压步聚1
	delay_us(15); // 15 us
	LCD_WriteControl(0x2e);	//升压步聚2
	delay_us(15); // 15 us
	LCD_WriteControl(0x2f);	//升压步聚3
	delay_us(150); // 15 us
	LCD_WriteControl(0x23);	//粗调对比度，可设置范围0x20～0x27
	delay_us(15); // 15 us
	LCD_WriteControl(0x81);	//微调对比度
	delay_us(15); // 15 us
	LCD_WriteControl(0x28);	//0x1a,微调对比度的值，可设置范围0x00～0x3f
	delay_us(15); // 15 us

	LCD_WriteControl(0xa2);	// 1/9偏压比（bias）
	delay_us(15); // 15 us
	LCD_WriteControl(0xa0);	//行扫描顺序：从上到下
	delay_us(15); // 15 us
	LCD_WriteControl(0xc8);	//列扫描顺序：从左到右
	delay_us(15); // 15 us
	LCD_WriteControl(0x40);	//起始行：第一行开始
	delay_us(15); // 15 us
	LCD_WriteControl(0xaf);	//打开显示
	delay_us(15); // 15 us
	LCD_WriteControl(0xa4);	
	delay_us(15); // 15 us

	HalLcd_HW_Clear();

	//DisplayByte_5x7(0,6,0x32);
	//DisplayByte_5x7(2,6,0x33);
	//DisplayByte_5x7(3,6,0x34);

	LCD_WriteString("step count is",0,0);

	//LCD_WriteInt(12456,0,6,0);
	//display_string_5x7(1,1,"abcdefghijklmnopqrstuvwxyz");
	//display_string_5x7(8,1,"uvwxyz0123456789");
	//while(1);


}

